{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["export const isObject = (value) => {\r\n  return typeof value === \"object\" && value !== null;\r\n};\r\n\r\nexport const extend = Object.assign;\r\n","import { extend, isObject } from \"@vue/shared\";\r\nimport { reactive, readonly } from \"./reactive\";\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  // receiver 是代理对象，即 proxy 对象\r\n  return function get(target, key, receiver) {\r\n    /**\r\n     * Reflect 的优势：\r\n     * 1. 后续 Object 上的方法都会被迁移到 Reflect 上，例如 Object.getPrototypeof()\r\n     * 2. 通过 target[key] = value 修改失败不会报错，而 Reflect.set 有返回值，可以判断是否修改成功\r\n     * 3. Reflect 方法具备返回值\r\n     */\r\n    const res = Reflect.get(target, key, receiver);\r\n    if (!isReadonly) {\r\n      // TODO。。。收集依赖\r\n    }\r\n    if (shallow) {\r\n      return res;\r\n    }\r\n    if (isObject(res)) {\r\n      // 【***】vue3 当取值时才进行递归处理子属性，而vue2是在初始化时就一次性递归到底对对象所有层级的属性进行代理\r\n      return isReadonly ? readonly(res) : reactive(res);\r\n    }\r\n    return res;\r\n  };\r\n}\r\nfunction createSetter(shallow = false) {\r\n  return function set(target, key, value, receiver) {\r\n    const result = Reflect.set(target, key, value, receiver);\r\n    return result;\r\n  };\r\n}\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n};\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet,\r\n};\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key ${key} failed`);\r\n  },\r\n};\r\nexport const readonlyHandlers = extend(\r\n  {\r\n    get: readonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\nexport const shallowReadonlyHandlers = extend(\r\n  {\r\n    get: shallowReadonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n","import { isObject } from \"@vue/shared\";\r\nimport { mutableHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReadonlyHandlers } from './baseHandlers'\r\nexport function reactive(target) {\r\n  return createReactiveObject(target, false, mutableHandlers);\r\n}\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandlers);\r\n}\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\r\n}\r\n\r\n// WeakMap 存储的key只能是对象，key是对对象的弱引用，会进行垃圾回收，不会造成内存泄漏\r\n// 使用两个 WeakMap 存储 proxy 对象，是因为 readonly 可以处理一个已经经过代理的对象\r\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\r\n  // reactive 只处理对象\r\n  if (!isObject(target)) {\r\n    return target;\r\n  }\r\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n  const existProxy = proxyMap.get(target);\r\n  if (existProxy) {\r\n    return existProxy; // 如果已经代理过了，则直接返回\r\n  }\r\n  const proxy = new Proxy(target, baseHandlers);\r\n  proxyMap.set(target, proxy); // 将要代理的对象和对应的代理结果缓存起来\r\n  return proxy;\r\n}\r\n"],"names":[],"mappings":"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"}